#!/usr/local/bin/racket
#lang racket

(require (planet dherman/json:4:=0))
(require racket/pretty)

(define (convert-json js-file-path)
  (let* ((file-name (list-ref (regexp-split #rx"\\.tree" js-file-path) 0))
         (in (open-input-file js-file-path))
         (out-jsexpr (open-output-file (string-append file-name "-jsexpr.scm") #:exists 'truncate/replace))
         (out-sform (open-output-file (string-append file-name "-sform.scm") #:exists 'truncate/replace))
         (jsexpr (read-json in))
         (sform (generalize-jsexpr jsexpr)))
    (pretty-display jsexpr)
    (pretty-write jsexpr out-jsexpr)
    (newline)
    (newline)
    (pretty-display sform)
    (newline)
    (newline)
    (pretty-write sform out-sform)
    (close-input-port in)
    (close-output-port out-jsexpr)
    (close-output-port out-sform)))

(define (generalize-variable hash key prefix suffix)
  (string->symbol (string-append prefix (hash-ref hash key) suffix)))

(define (generalize-variable-list hash key prefix suffix)
  (map (lambda (e) (string->symbol (string-append prefix e suffix))) (hash-ref hash key)))

(define (generalize-hash-value hash key)
  (generalize-jsexpr (hash-ref hash key)))

(define (generalize-hash type hash)
  (cond ((eq? type 'Program) ;; Program
         `(begin ,@(generalize-hash-value hash 'elements)))
        ((or (eq? type 'ExpressionMacroDefinition) ;; MacroDefinition
             (eq? type 'StatementMacroDefinition))
         (let* ((macro-name (generalize-variable hash 'macroName "" "-Macro"))
                (literals (generalize-variable-list hash 'literals "LK-" ""))
                (rules (generalize-hash-value hash 'syntaxRules)))
           `(define-syntax ,macro-name
              (syntax-rules ,literals ,@rules))))
        ((eq? type 'SyntaxRule) ;; SyntaxRule
         `((_ ,@(generalize-hash-value hash 'pattern)) ,(generalize-hash-value hash 'template)))
        ((or (eq? type 'Brace) ;; Brace
             (eq? type 'Paren) ;; Paren
             (eq? type 'Bracket)) ;; Bracket
         `("JS" ,(string-downcase (symbol->string type)) ,@(generalize-hash-value hash 'elements)))
        ((eq? type 'Function) ;; Function
         (let* ((name (hash-ref hash 'name))
                (body (generalize-hash-value hash 'elements))
                (params (generalize-variable-list hash 'params "V-" "")))
           (if (eq? name #\nul)
               `(lambda ,params ,(if (eq? body '()) `(quote ,body) `(begin ,@body)))
               `(define (,name ,@params) ,(if (eq? body '()) `(quote ,body) `(begin ,@body))))))
        ((eq? type 'FunctionCall) ;; FunctionCall
         (let* ((name (generalize-hash-value hash 'name))
                (arguments (generalize-hash-value hash 'arguments)))
           `("JS" "application" ,name ,@arguments)))
        ((eq? type 'MacroName) ;; MacroName
         (generalize-variable hash 'name "" "-Macro"))
        ((or (eq? type 'Variable) ;; Variable
             (eq? type 'IdentifierVariable) ;; IdentifierVariable
             (eq? type 'ExpressionVariable) ;; ExpressionVariable
             (eq? type 'StatementVariable)) ;; StatementVariable
         (generalize-variable hash 'name "V-" ""))
        ((eq? type 'LiteralKeyword) ;; LiteralKeyword
         (generalize-variable hash 'name "LK-" ""))
        ((eq? type 'NumericLiteral)
         (generalize-hash-value hash 'value))
        ((eq? type 'Punctuator) ;; Punctuator
         (hash-ref hash 'value))
        ((eq? type 'ReturnStatement) ;; ReturnStatement
         `("JS" "return" ,(generalize-hash-value hash 'value)))
        ((eq? type 'UnaryExpression)
         `("JS" "op1" ,(hash-ref hash 'operator) ,(generalize-hash-value hash 'expression)))
        ((eq? type 'BinaryExpression) ;; BinayExpression
         `("JS" "op2" ,(hash-ref hash 'operator) ,(generalize-hash-value hash 'left) ,(generalize-hash-value hash 'right)))
        ((eq? type 'ConditionalExpression)
         `("JS" "conditional" ,(generalize-hash-value hash 'condition) ,(generalize-hash-value hash 'trueExpression) ,(generalize-hash-value hash 'falseExpression)))
        ((eq? type 'MacroForm) ;; MacroForm
         (generalize-hash-value hash 'inputForm))
        (#t
         (hash-map hash
                   (lambda (key value)
                     (list key (generalize-jsexpr value)))))))

(define (generalize-jsexpr jsexpr)
  (cond ((hash? jsexpr) ;; hash table
         (let* ((type (string->symbol (hash-ref jsexpr 'type)))
                (rest (generalize-hash type (hash-remove jsexpr 'type))))
           rest))
        ((list? jsexpr) ;; list
         (map generalize-jsexpr jsexpr))
        (#t ;; other
         jsexpr)))

(define (main args)
  (convert-json (vector-ref args 0)))

(main (current-command-line-arguments))