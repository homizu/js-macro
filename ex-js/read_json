#!/usr/local/bin/racket
#lang racket

(require (planet dherman/json:4:=0))
(require racket/pretty)

(define (convert-json js-file-path)
  (let* ((file-name (list-ref (regexp-split #rx"\\.tree" js-file-path) 0))
         (in (open-input-file js-file-path))
         (out-jsexpr (open-output-file (string-append file-name "-jsexpr.scm") #:exists 'truncate/replace))
         (out-sform (open-output-file (string-append file-name "-sform.scm") #:exists 'truncate/replace))
         (jsexpr (read-json in))
         (sform (generalize-jsexpr jsexpr)))
    (pretty-display jsexpr)
    (pretty-write jsexpr out-jsexpr)
    (newline)
    (newline)
    (pretty-display sform)
    (newline)
    (newline)
    (pretty-write sform out-sform)
    (close-input-port in)
    (close-output-port out-jsexpr)
    (close-output-port out-sform)))

(define (generalize-variable hash key prefix suffix)
  (list (list key (string->symbol (string-append prefix (hash-ref hash key) suffix)))))

(define (generalize-hash type hash)
  (cond ((or (eq? type 'ExpressionMacroDefinition)
             (eq? type 'StatementMacroDefinition))
         (hash-map hash
                   (lambda (key value)
                     (cond ((eq? key 'macroName)
                            (list key (string->symbol (string-append value "-Macro"))))
                           ((eq? key 'literals)
                            (list key (map (lambda (element) (string->symbol (string-append "LK-" element))) value)))
                           (#t
                            (list key (generalize-jsexpr value)))))))
        ((eq? type 'Function)
         (hash-map hash (lambda (key value)
                          (if (eq? key 'params)
                              (list key (map (lambda (element) (string->symbol (string-append "P-" element))) value))
                              (list key (generalize-jsexpr value))))))
        ((eq? type 'MacroName)
         (generalize-variable hash 'name "" "-Macro"))
        ((eq? type 'Variable)
         (generalize-variable hash 'name "V-" ""))
        ((eq? type 'IdentifierVariable)
         (generalize-variable hash 'name "V-" ""))
        ((eq? type 'ExpressionVariable)
         (generalize-variable hash 'name "V-" ""))
        ((eq? type 'StatementVariable)
         (generalize-variable hash 'name "V-" ""))
        ((eq? type 'LiteralKeyword)
         (generalize-variable hash 'name "LK-" ""))
        (#t
         (hash-map hash
                   (lambda (key value)
                     (list key (generalize-jsexpr value)))))))

(define (generalize-jsexpr jsexpr)
  (cond ((hash? jsexpr) ;; hash table
         (let* ((type (string->symbol (hash-ref jsexpr 'type)))
                (rest (generalize-hash type (hash-remove jsexpr 'type))))
           (append (list type) rest)))
        ((list? jsexpr) ;; list
         (map (lambda (element) (generalize-jsexpr element)) jsexpr))
        (#t ;; other
         jsexpr)))


;; (define (generalize-jsexpr jsexpr)
;;   (cond ((hash? jsexpr) ;; hash table
;;          (let* ((result (list (string->symbol (hash-ref jsexpr 'type))))
;;                 (rest (hash-remove jsexpr 'type)))
;;            (append result
;;                    (hash-map rest 
;;                              (lambda (key value) (list key (generalize-jsexpr value)))))))
;;         ((list? jsexpr) ;; list
;;          (map (lambda (element) (generalize-jsexpr element)) jsexpr))
;;         (#t ;; other
;;         jsexpr)))


(define (main args)
  (convert-json (vector-ref args 0)))

(main (current-command-line-arguments))