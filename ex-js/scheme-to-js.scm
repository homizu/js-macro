(import (slib format))
(import (pregexp))

(define indent-level 0)
(define buffer '())
(define (bformat . arg*)
  (let ((output (apply format (cons #f arg*))))
    (set! buffer (cons output buffer))))
(define (bindent delta)
  (set! indent-level (+ indent-level delta)))
(define (bnewline . delta)
  (bindent (if (null? delta) 0 (car delta)))
  (bformat "~%~v,a" indent-level ""))
(define (bflush)
  (let ((result (apply string-append (reverse buffer))))
    (breset)
    result))
(define (bprint . port)
  (if (null? port)
      (display (buffer-flush))
      (display (buffer-flush) (car port))))
(define (bseparating f sep l)
  (fold-left (lambda (sep? e)
           (if sep? (bformat "~a" sep))
           (f e)
           #t)
         #f l))
(define (breset)
  (set! buffer '())
  (set! indent-level 0))

(define (symbol->list sym)
  (string->list (symbol->string sym)))
;;(define (list->symbol l)
;;  (string->symbol (list->string l)))

(define unwanted-chars (symbol->list '\x60;\x2E;*))

(define (do-symbol e)
  (let* ((chars (symbol->list e))
         (str (list->string (map (lambda (c)
                                   (if (memq c unwanted-chars) #\_ c)) ;; . ` * を _ にする
                                 chars))))
    (bformat "~a" (string->symbol (pregexp-replace "^(V|LK)-" str ""))))) ;; 変数名の V- と LK- を取り除く

(define (do-begin e)
  (for-each (lambda (v) (s2j v) (bformat ";") (bnewline)) e))

(define (do-fargs arg*)
  (bformat " (") (bseparating do-symbol ", " arg*) (bformat ") "))

(define (do-define e)
  (let ((name (car e))
        (body (cadr e)))
    (bformat "var ") (do-symbol name) (bformat " = ")
    (s2j body) ; (do-lambda (cdr body))
    (bformat ";")))

(define (do-lambda e)
  (let ((arg* (car e))
        (body (cdr e)))
    (bformat "function")
    (do-fargs arg*)
    (bformat "{")
    (bnewline 2)
    (do-begin body)
    (bnewline -2)
    (bformat "}")))

(define (do-JS e)
  (let ((type (car e))
        (body (cdr e)))
    (cond ;((eq? type "brace")
          ; (bformat "{")
          ; (s2j body)
          ; (bformat "}"))
          ;((eq? type "paren")
          ; (bformat "(")
          ; (s2j body)
          ; (bformat ")"))
          ;((eq? type "bracket")
          ; (bformat "[")
          ; (s2j body)
          ; (bformat "]"))
          ((eq? type "const") (bformat "~a" (first body)))
          ((eq? type "number") (bformat "~a" (first body)))
          ((eq? type "array") '())
          ((eq? type "object") '())
          ((eq? type "propAssign") '())
          ((eq? type "getter") '())
          ((eq? type "setter") '())
          ((eq? type "new") '())
          ((eq? type "propAccess") '())
          ((eq? type "funcCall") '())
          ((eq? type "postfix") '())
          ((eq? type "unary") '())
          ((eq? type "binary") '())
          ((eq? type "assignment") '())
          ((eq? type "conditional") '())
          ((eq? type "block") '())
          ((eq? type "variable") '())
          ((eq? type "empty") '())
          ((eq? type "if") '())
          ((eq? type "dowhile") '())
          ((eq? type "while") '())
          ((eq? type "for") '())
          ((eq? type "forin") '())
          ((eq? type "return") '())
          ((eq? type "with") '())
          ((eq? type "switch") '())
          ((eq? type "case") '())
          ((eq? type "default") '())
          ((eq? type "labelled") '())
          ((eq? type "throw") '())
          ((eq? type "try") '())
          ((eq? type "catch") '())
          ((eq? type "finaly") '())
          ((eq? type "debugger") '())
          ((eq? type "function") '())
          (error 'do-JS "Invalid expression" e))))

(define (do-list e)
  (let ((head (car e)))
    (cond ((symbol? head)
           (cond ((eq? head 'begin) (do-begin (cdr e)))
                 ((eq? head 'define) (do-define (cdr e)))
                 ((eq? head 'lambda) (do-lambda (cdr e)))))
          ((eq? head "JS") (do-JS (cdr e)))
          (error 'do-list "Invalid elements." e))))

(define (s2j e)
  (cond ((eq? #\nul e) (display "null"))
        ((boolean? e) (error 's2j "bool: This cannot happen"))
        ((symbol? e) (do-symbol e))
        ((number? e) (error 's2j "num: This cannot happen"))
        ((char? e) (error 's2j "string: This cannot happen"))
        ((list? e) (do-list e))
        ((or (vector? e) (port? e) (procedure? e))
         (error 's2j "Invalid elements in the Scheme program (port or procedure)." e))))

;; (define (scheme-to-javascript scm js-file-path)
;;   (let ((out (transcoded-port (open-file-output-port
;;                                js-file-path
;;                                (file-options no-fail))
;;                               (make-transcoder utf-8-codec))))
;;     (put-string out (s2j scm))))

(define (scheme-to-javascript scm)
  (breset)
  (s2j scm)
  (bflush))